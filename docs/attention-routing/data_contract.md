# Attention Routing Data Contract

## 1. Purpose and Scope
This document freezes the **canonical, cutoff-safe data contract** for attention-routing using repository-inspected sources only:
- ingestion pipeline code (`packages/repo-ingestion/...`),
- runtime SQLite schema generated by `init_db` (verified at `/tmp/attention_contract_full.sqlite`),
- routing/evaluation artifact writers (`packages/repo-routing/...`, `packages/evaluation-harness/...`).

Scope:
- What exists as-of cutoff,
- How to reconstruct as-of state,
- What downstream joins are allowed without leakage,
- What is currently UNKNOWN/TODO.

## 2. Repository Ingestion Overview
- **Entrypoints (Typer CLI):** `packages/repo-ingestion/src/gh_history_ingestion/cli/app.py`
  - `repo-ingestion ingest` → full backfill (`ingest/backfill.py`)
  - `repo-ingestion incremental` → watermark-driven update (`ingest/incremental.py`)
  - `repo-ingestion pull-requests` → PR-window backfill (`ingest/pull_requests.py`, optional `--with-truth`)
- **Pipeline stages (fetch/parse/store):**
  1. Fetch GitHub REST resources (repos, pulls/issues/events/reviews/comments/files, etc.).
  2. Normalize to canonical events (`events/normalizers/*.py`).
  3. Upsert identity/object rows (`storage/upsert.py`).
  4. Insert canonical event log rows (`events` table).
  5. Rebuild interval tables from events (`intervals/rebuild.py`).
- **Primary output:** SQLite DB at `data/github/<owner>/<repo>/history.sqlite` (`cli/paths.py`).
- **Operational metadata output:** `qa_reports`, `ingestion_gaps`, `watermarks` (inside DB).
- **Important:** ingestion package does **not** write `snapshot.json` / `inputs.json`; those are written by routing/eval artifact code (`repo-routing/artifacts/writer.py`).
- **Determinism guarantees:**
  - Event identity is deduped via unique `events.event_key` (`upsert.insert_event`).
  - As-of readers and artifact JSON writes use deterministic ordering/sorting (`HistoryReader`, `_write_json_deterministic`).
  - Runtime-dependent fields remain: `qa_reports.created_at`, run `generated_at`, and ingestion wall-clock ordering of API pages.

## 3. Core Temporal Model
- **Cutoff unit of prediction:** (`repo`, `pr_number`, `cutoff`).
- **As-of semantics:**
  - Interval-active row when `start_event.occurred_at <= cutoff` and (`end_event is NULL` OR `cutoff < end_event.occurred_at`).
  - This is **start-inclusive, end-exclusive** (verified in `HistoryReader` queries and `evaluation_harness.truth.intent_truth_from_review_requests`).
- **Leakage rules:**
  - Inputs must be computable from tables/artifacts available at `<= cutoff`.
  - Post-cutoff outcomes (who responded, TTFR, merge state after cutoff) are labels/metrics only.
  - Use pinned artifacts keyed by snapshot SHAs (see §8).
- **Human-knowable-at-cutoff tests (required):**
  1. Remove post-cutoff rows: feature must not change.
  2. No feature may encode responder identity/ordering after cutoff.
  3. Use pinned SHA artifacts, never working-tree HEAD files.
  4. Prefer event/interval state over mutable “latest snapshot” columns when reconstructing historical state.

## 4. Storage Layout
- **Canonical DB:**
  - `data/github/<owner>/<repo>/history.sqlite`
- **Routing/eval run artifacts (not ingestion output):**
  - `data/github/<owner>/<repo>/eval/<run_id>/...`
  - per PR: `prs/<pr_number>/snapshot.json`, `inputs.json`, `routes/<router>.json`, optional `features/<router>.json`, `llm/<router>/<step>.json`
  - run-level: `manifest.json`, `per_pr.jsonl`, `report.json`, `report.md`
- **Pinned artifact directories:**
  - CODEOWNERS: `data/github/<owner>/<repo>/codeowners/<base_sha>/CODEOWNERS` (`repo_routing.paths.repo_codeowners_path`)
  - Area overrides: `data/github/<owner>/<repo>/routing/area_overrides.json` (`repo_routing.exports.area.load_repo_area_overrides`)
- Team roster expansion (optional): `data/github/<owner>/<repo>/routing/team_roster.json`
- **Naming/versioning in artifacts:**
  - `snapshot.json`: `kind=pr_snapshot`, `version=v0`
  - route artifact: `kind=route_result`, `version=v0`
  - eval manifest: `kind=eval_manifest`, `version=v0`

## 5. SQLite Schema Summary
Source of truth: `packages/repo-ingestion/src/gh_history_ingestion/storage/schema.py`, validated against generated DB `/tmp/attention_contract_full.sqlite`.

### 5.1 Identity / metadata tables
- `repos` — grain: repo
  - PK: `id`; unique: `full_name`
  - time fields: `created_at`, `updated_at`, `pushed_at`
- `users` — grain: user
  - PK: `id`
  - time fields: none
- `teams` — grain: team
  - PK: `id`
  - time fields: none
- `labels` — grain: label
  - PK: `id`; logical FK: `repo_id`
  - time fields: none
- `milestones` — grain: milestone
  - PK: `id`; logical FK: `repo_id`
  - time fields: `created_at`, `updated_at`, `due_on`, `closed_at`

### 5.2 Core issue/PR objects
- `issues` — grain: issue row
  - PK: `id`; unique (`repo_id`,`number`)
  - joins: `repo_id`, `user_id`
  - time fields: `created_at`, `updated_at`, `closed_at`
- `pull_requests` — grain: PR row
  - PK: `id`; unique (`repo_id`,`number`)
  - joins: `repo_id`, `issue_id`, `user_id`
  - time fields: `created_at`, `updated_at`, `closed_at`, `merged_at`
- `pull_request_files` — grain: file at specific PR head
  - PK: (`repo_id`,`pull_request_id`,`head_sha`,`path`)
  - fields: `status`, `additions`, `deletions`, `changes`
  - indexes: `ix_pr_files_repo_pr_head(repo_id,pull_request_id,head_sha)`, `ix_pr_files_repo_path(repo_id,path)`
  - time fields: **none in row** (time is implicit via `head_sha` and head interval table)

### 5.3 Reviews/comments/events
- `reviews` — grain: review
  - PK: `id`; joins: `repo_id`, `pull_request_id`, `user_id`
  - time field: `submitted_at`
- `comments` — grain: comment (issue/review/diff)
  - PK: `id`; joins: `repo_id`, `issue_id`, `pull_request_id`, `review_id`, `user_id`
  - time fields: `created_at`, `updated_at`
- `events` — grain: normalized event log
  - PK: `id`; unique `event_key`
  - joins: `repo_id`, `actor_id`, `subject_type/subject_id`, optional `object_type/object_id`
  - time field: `occurred_at` (canonical event time)

### 5.4 Repo graph / release state
- `commits` — PK (`repo_id`,`sha`); time fields `authored_at`, `committed_at`
- `refs` — PK `id`, unique (`repo_id`,`ref_type`,`name`); no explicit time field
- `releases` — PK `id`; time fields `created_at`, `published_at`

### 5.5 Ingestion operational tables
- `watermarks` — PK `id`, unique (`repo_id`,`resource`)
  - time field: `updated_at`
- `ingestion_gaps` — PK `id`
  - time field: `detected_at`
- `qa_reports` — PK `id`
  - time field: `created_at`

### 5.6 Interval tables (as-of state)
- `issue_state_intervals(issue_id,state,start_event_id,end_event_id)`
- `issue_content_intervals(issue_id,title,body,start_event_id,end_event_id)`
- `issue_label_intervals(issue_id,label_id,start_event_id,end_event_id)`
- `issue_assignee_intervals(issue_id,user_id,start_event_id,end_event_id)`
- `issue_milestone_intervals(issue_id,milestone_id,start_event_id,end_event_id)`
- `pull_request_draft_intervals(pull_request_id,is_draft,start_event_id,end_event_id)`
- `pull_request_head_intervals(pull_request_id,head_sha,head_ref,start_event_id,end_event_id)`
- `pull_request_review_request_intervals(pull_request_id,reviewer_type,reviewer_id,start_event_id,end_event_id)`
- `comment_content_intervals(comment_id,body,start_event_id,end_event_id)`
- `review_content_intervals(review_id,body,state,start_event_id,end_event_id)`

### 5.7 Optional raw snapshots
- `object_snapshots(event_id,object_type,object_id,payload_json)` exists in schema.
- Current ingestion code has **no active writer** to this table (UNKNOWN if used outside repo).

## 6. As-of Reconstruction via Interval Tables
- Interval tables are rebuilt from ordered events (`ORDER BY occurred_at, id`) in `intervals/rebuild.py`.
- Open interval convention: `end_event_id IS NULL` means active until superseded.
- Boundary semantics (verified in reader SQL):
  - active if `start_event.occurred_at <= cutoff` and (`end_event` absent OR `cutoff < end_event.occurred_at`).
- Example reconstructions (implemented in `HistoryReader`):
  - Draft state as-of cutoff: `pull_request_draft_intervals` + `events` join.
  - PR title/body as-of cutoff: `issue_content_intervals` + `events` join (falls back to `issues` if strict mode disabled).
  - Head SHA as-of cutoff: `pull_request_head_intervals` + `events` join.
  - Active review requests set as-of cutoff: `pull_request_review_request_intervals` + `events` join, then resolve `reviewer_id` via `users`/`teams`.

## 7. Primary Objects at Cutoff
- **PR Snapshot** (`PullRequestSnapshot`, source: `HistoryReader.pull_request_snapshot`)
  - Fields: `repo`, `number`, `pull_request_id`, `issue_id`, `author_login`, `created_at`, `title`, `body`, `base_sha`, `head_sha`, `changed_files[]`, `review_requests[]`.
- **Change Surface** (`changed_files` from `pull_request_files` at as-of `head_sha`)
  - Per file: `path`, `status`, `additions`, `deletions`, `changes`.
- **Ownership context**
  - CODEOWNERS pinned path: `codeowners/<base_sha>/CODEOWNERS`.
  - Area mapping: `routing/area_overrides.json` + fallback `default_area_for_path(path)`.
- **Active review requests**
  - From `pull_request_review_request_intervals` active at cutoff; users/teams resolved from `users`/`teams`.
- **Snapshot bundle artifacts written during eval/routing**
  - `snapshot.json` (`PRSnapshotArtifact`)
  - `inputs.json` (`PRInputBundle`: includes gates, areas, review requests, recent activity if enabled)

## 8. Pinned Artifacts
- **CODEOWNERS**
  - Contract path: `data/github/<owner>/<repo>/codeowners/<base_sha>/CODEOWNERS`.
  - Keyed by PR `base_sha` (from as-of PR snapshot).
  - Used by CODEOWNERS baseline only when available; otherwise high-risk/empty output.
- **Area/module mapping**
  - `data/github/<owner>/<repo>/routing/area_overrides.json`
  - Supported shapes: object map or list entries (`{pattern,area}` etc.), parsed in `exports/area.py`.
- **Other pinned configs discovered**
  - Router scoring config JSON (e.g., `experiments/configs/v0.json`) used by `stewards` router.
  - Eval run `manifest.json` captures router/config identity for reproducibility.

## 9. Identity Model
- **Users**
  - Canonical key: `users.id`; login in `users.login`; type in `users.type`.
  - Bot filtering in harness/routes uses `users.type == 'Bot'` plus fallback login suffix `[bot]` in some paths.
- **Teams**
  - Key: `teams.id`; human-readable `teams.slug`.
  - Team membership table is **absent** in canonical schema (no direct membership expansion available from DB alone).
- **Eligibility rules in harness (current code)**
  - Non-bot and non-author filters applied in truth/metrics via `exclude_bots`, `exclude_author` defaults.
  - Routing truth function currently: `behavior_truth_first_eligible_review(...)` in `evaluation_harness/truth.py`.
  - **Behavior truth policy (current):** first eligible post-cutoff review response in `(cutoff, cutoff+window]` (default window `48h`), with non-author/non-bot filters.

## 10. Candidate Generation Contract
- **Entity types supported in router outputs:** `user`, `team` (`router/base.py`).
- **Observed candidate sources in current codebase:**
  - Stewards analysis candidate pool (`analysis/engine.py`): distinct users with comments/reviews in lookback window up to cutoff.
  - Mentions baseline: PR body `@user` / `@org/team` extraction (`router/baselines/mentions.py`).
  - CODEOWNERS baseline: owners from pinned CODEOWNERS text (`router/baselines/codeowners.py`).
  - Active review requests are available from snapshot inputs, but **not** currently integrated into stewards candidate pool logic.
- **Versioning requirements (contract):**
  - Persist `candidate_gen_version` in model outputs and eval artifacts (features, routes, manifest) when available.
  - Candidate set must be frozen per evaluation run and recoverable from artifacts.
  - Any source change (e.g., add requested reviewers to pool) is a contract-breaking candidate-gen version bump.

## 11. Time Windows and Aggregation Conventions
Verified defaults in code:
- Eval defaults (`evaluation_harness/config.py`):
  - `cutoff_policy="created_at"`
  - `intent_truth_window=60m`
  - `candidate_pool_lookback_days=180`
  - `top_k=5`, `hit_ks=(1,3,5)`
- Stewards scoring defaults (`repo_routing/scoring/config.py`):
  - candidate pool lookback `180d`
  - decay half-life `30d`, decay lookback `180d`
  - event weights: review `1.0`, review_comment `0.4`, issue/review comment `0.2`
- PR input builder options (`inputs/models.py`): optional recent activity window `30d`, limit `200`.

If a task needs other windows and none exist in code, treat as **recommendation only** and version explicitly in task config/labels.

## 12. Evidence Logging Contract
Per candidate/route output (existing schema):
- `RouteResult`: `repo`, `pr_number`, `as_of`, `top_k`, `risk`, `confidence`, `notes[]`, `candidates[]`.
- Each candidate: `target{type,name}`, `score`, `evidence[]` where evidence item is `{kind, data}`.
- Deterministic JSON writing: sorted keys + stable order (`artifacts/writer.py`).

Recommended minimum evidence payload for attention-routing tasks:
- candidate source(s),
- key feature values used for score,
- filters applied (bot/author exclusion, min activity),
- model/config version identifiers.

Size/format constraints:
- Keep evidence compact (no raw full timelines/blobs);
- JSON only, deterministic ordering.

## 13. Known Gaps / Non-Data
1. No team membership table in canonical DB; team→user expansion is external/UNKNOWN.
2. `behavior_truth_first_eligible_review` defaults are versioned policy knobs (`window`, qualifying events) and must be mirrored in manifests/docs when changed.
3. `object_snapshots` table exists but no ingestion writer observed.
4. Ingestion does not natively persist `candidate_gen_version` artifacts (routing/eval artifacts do when feature metadata is available).
5. No explicit foreign key constraints for many logical joins beyond schema declarations (SQLite enforcement depends on runtime PRAGMA; not guaranteed here).
6. CODEOWNERS artifacts are expected on disk but ingestion package does not create them.

## 14. Change Policy
- **Breaking change (requires contract version bump + re-eval):**
  - Add/remove/rename DB columns used by routing/eval,
  - change interval boundary semantics,
  - change eligibility filters (bot/author),
  - change routing truth definition,
  - change candidate generation source set,
  - change pinned artifact keying (e.g., base_sha path layout).
- **Non-breaking change:** additive artifact fields that do not alter existing semantics.
- **Required process on breaking change:**
  1. bump data-contract version in this doc,
  2. bump label/candidate-gen versions,
  3. rerun offline eval and regenerate manifests,
  4. document migration notes.

---

## Appendix A — Verified Facts Checklist
- Verified CLI ingestion entrypoints in `repo-ingestion` (`ingest`, `incremental`, `pull-requests`).
- Verified default DB path: `data/github/<owner>/<repo>/history.sqlite`.
- Generated and inspected full schema DB at `/tmp/attention_contract_full.sqlite` using `init_db`.
- Verified table inventory includes identity/object/event/interval/operational tables listed in §5.
- Verified `pull_request_files` composite PK and explicit indexes (`ix_pr_files_repo_pr_head`, `ix_pr_files_repo_path`).
- Verified interval open-ended convention uses `end_event_id IS NULL`.
- Verified interval boundary predicate is start-inclusive/end-exclusive in reader SQL.
- Verified `HistoryReader.pull_request_snapshot` reconstruction sources (issue content interval, head interval, files by head SHA, active review requests).
- Verified artifact paths for `snapshot.json`, `inputs.json`, routes under eval run dir.
- Verified `snapshot.json` and `inputs.json` field shapes by executing a local eval sample run (`/tmp/attention_contract_eval/...`).
- Verified pinned CODEOWNERS path function: `codeowners/<base_sha>/CODEOWNERS`.
- Verified area overrides path and parser: `routing/area_overrides.json`.
- Verified harness unit is PR at cutoff and routing metrics consume `TruthLabel(repo, pr_number, cutoff, targets)`.
- Verified harness truth SQL in `truth.py` uses post-cutoff window semantics `(cutoff, cutoff+window]` plus non-author/non-bot filters.

## Appendix B — Open TODOs
1. Define authoritative team-membership snapshot source for team→user evaluation.
2. Decide whether `object_snapshots` should be populated or removed from contract scope.
3. Confirm SQLite foreign key enforcement policy (`PRAGMA foreign_keys`) for production runs.
4. Document canonical CODEOWNERS artifact producer (currently outside ingestion package).
5. Add explicit schema docs for `inputs.json`/`features/*.json` versioning guarantees.
6. Define migration playbook for interval schema changes.
